# 动态规划

闫氏DP分析法：从集合角度看最优化问题

在一个有限集合中求最值，或者求个数



## 摘花生模型(线性DP)

### 走一次

#### [1015. 摘花生](https://www.acwing.com/problem/content/1017/)

矩形数据，从左上角走到右下角，只能向右或向下走，求经过的最大值或者最小值。

```c++
 	for (int i = 1; i <= n; i++)
 		for (int j = 1; j <= m; j++)
     		//f[i][j] = max(f[i - 1][j], f[i][j - 1]) + a[i][j];
          	f[j] = max(f[j], f[j-1]) + a[i][j];
```



#### [898. 数字三角形](https://www.acwing.com/problem/content/900/)

三角形数据，从第一层走到最后一层，只能从左上或者上面来

`f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j])`

注意：初始化时候需要注意边界问题

```c++
// 二维    
	for(int i = 1; i <= n; i++)
        // 注意这里j从0到i+1,因为对于边界点,它的上一层只有一条路径通向它
        for(int j = 0; j <= i+1; j++)  
            f[i][j]=-INF;      //初始化近似为-∞ 

// 可以采用倒序，从下往上，不需要考虑边界问题
    for (int i = n; i >= 1; i--)
        for (int j = i; j >= 1; j--)
            f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + f[i][j];
```



#### [1018. 最低通行费](https://www.acwing.com/problem/content/1020/)

矩形数据，步数限定 $2N-1$ 说明了只能 向右走 和 向下走，简化成摘花生模型

这题不同于摘花生的地方在于，他的属性是最小值，因此需要在代码上作出一点点改变

例如，需要先把所有状态初始化为正无穷，初始化状态的起点（dp求最小值必须要的步骤）

```c++
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            if (i == 1 && j == 1) f[i][j] = w[i][j];
            else {
                f[i][j] = INF;
                if (i > 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);
                if (j > 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);
            }
        }
```



### 走两次

#### [1027. 方格取数](https://www.acwing.com/problem/content/1029/)

矩形数据，区别点：**出发两次**

- 一定要 $2$ 次一次走，如果一次一次走，第一次的结果会影响第二次。

- $k = i_1 + j_1 = i_2 + j_2$： 两个小朋友同时走, 每个人走的步数和是一样的

- $f[i_1, j_1, i_2, j_2]$：由摘花生问题可以推广出从 $(1, 1),(1, 1)$ 走到 $(i_1, j_1),(i_2, j_2)$ 能获得的最大花生数目

- 由上面的两条性质可以推出三维的状态转移方程 $f[i_1,k-i_1,i_2,k-i_2]  ->  f[k, i_1, i_2]$：两个小朋友同时走 $k$ 步,从 $(1,1),(1,1)$ 走到 $(i_1,j_1),(i_2,j_2)$ 能获得的最大花生数目。

- 0:代表小朋友要到下边一个格子

- 1:代表小朋友要到右边一个格子

- 难点:∀格子仅能取一次. 两个小朋友在同一个格子→必有$i1==i2,j1==j2$,而后边状态限制同时走,所以当$i1==i2$ 时便走到同一格.
  至此解决状态表示问题, 下面考虑集合划分
   ![](https://cdn.acwing.com/media/article/image/2019/09/28/1833_6766f376e1-Snipaste_2019-09-28_17-13-35.png)

  $f[i_1-1,j_1,i_2-1,j_2]->f[k-1,i_1-1,i_2-1]$:代表两个小朋友都走了$k-1$,小朋友1要从$(i_1-1,j_1)$到$(i_1,j_1)$,小朋友2要从$(i_2-1,j_2)$到$(i_2, j_2)$

  所以需要判断$(i_1,j_1),(i_2,j_2)$是否是同一个格子,若是则仅需要加上一个权重,反之两个都需要

```c++
    for (int k = 2; k <= n + n; ++ k) {					// 总步数
        for (int i = 1; i < k && i <= n; ++ i) {		// i1
            for (int j = 1; j < k && j <= n; ++ j) {	// i2
                int t = w[i][k - i];
                if(i!=j) t += w[j][k - j];
                int &x = f[k][i][j];
                x = max(x, f[k-1][i][j]);
                x = max(x, f[k-1][i-1][j-1]);
                x = max(x, f[k-1][i][j-1]);
                x = max(x, f[k-1][i-1][j]);
                x += t;   
            }

```



#### [275. 传纸条](https://www.acwing.com/problem/content/277/)

网格数据，区别：**来回各一次，每个数据只能使用一次**

模型是方格取数，因为寻找的是最大值，初始化值都大于0

方格取数的最优解可以变成不经过重复点的最优解

![传纸条.png](https://cdn.acwing.com/media/article/image/2023/02/21/165226_11dca408b1-%E4%BC%A0%E7%BA%B8%E6%9D%A1.png)



```c++
    for (int k = 2; k <= n + m; ++ k) 
        for (int i = 1; i < k && i <= n; ++ i) 
            for (int j = 1; j < k && j <= n; ++ j) {
                int t = w[i][k - i];
                if(i!=j) t += w[j][k - j];
                int &x = f[k][i][j];
                x = max(x, f[k-1][i][j]);
                x = max(x, f[k-1][i-1][j-1]);
                x = max(x, f[k-1][i][j-1]);
                x = max(x, f[k-1][i-1][j]);
                x += t;
            }
```



## 最长上升子序列模型



#### [895. 最长上升子序列](https://www.acwing.com/problem/content/897/)

一个序列，从左往右，求连续上升的子序列的最大值

```c++
    for (int i = 1; i <= n; i++) {
        f[i] = 1;	// 只有a[i]一个数，本身算一个序列
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i]) 	// 如果符合“上升”的条件，就尝试更新f数组
                f[i] = max(f[i], f[j] + 1);
        }
        res = max(res, f[i]);
    }
```



#### [1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/description/1019/)

条件1：按照高度递减的顺序来移动

条件2：选定从左或从右就不能更改

思路：

从任意一点出发，求一个最长下降子序列长度最大

两个方向，故从左到右和从右到左分别求一次，最大值即答案

```c++
	for (int i = 1; i <= m; i++) {
     	f[i] = 1;
        for (int j = 1; j < i; j++)
   			if (w[i] < w[j]) f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);
   	}
   	memset(f, 0, sizeof f);
  	for (int i = n - 1; i >= 0; i--) {
      	f[i] = i;
     	for (int j = n - 1; j > i; j--) 
         	if (w[i] < w[j]) f[i] = max(f[i], f[j] + 1);
      	res = max(res, f[i]);
   	}
```





#### [1014. 登山 - AcWing题库](https://www.acwing.com/problem/content/1016/)

条件1：按照编号递增的顺序来浏览		→	必须是子序列

条件2：相邻两个景点不能相同 			   

条件3：一旦开始下降，就不能上升		→ 	形状大概是先上升后下降 ^ 

目标：求最多能浏览多少景点				  →	求最大值

思路：

枚举中间的分界点，左边是一个最长上升子序列，右边是一个最长下降子序列

(正向上升 = 逆向下降)

`h[k] = f[k] + g[k] - 1, res = max(h)` 

处理过程中可以先预处理两个子序列，在枚举交界点，可以将$O(n^3)$优化成$O(n^2)$

```c++
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        for (int j = 1; j < i; j++) 
            if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
    }
    for (int i = n; i; i--) {
        g[i] = 1;
        for (int j = n; j > i; j--)
            if (a[j] < a[i]) g[i] = max(g[i], g[j] + 1);
    }

    int res = 0;
    for (int i = 1; i <= n; i++) {
        res = max(res, f[i] + g[i] - 1);
    }
```



#### [482. 合唱队形](https://www.acwing.com/problem/content/484/)

与登山问题相同，最少去掉多少个同学 等同于 最多保留多少个同学



#### [1012. 友好城市](https://www.acwing.com/problem/content/1014/)

条件1：每个城市上只能建立一座桥

条件2：所有的桥与桥之间不能相交

目标：最多可以建多少桥？					→	求最大值

所有合法的建桥方式 等于 上升子序列

思路：

上坐标从小到大枚举选择到的桥，其对应下坐标也必然是从小到大的

在上坐标排序的情况下，下坐标次序不是从小到大的，则必然不合法（会有相交）

题目可以演变成：桥以上坐标从小到大排序后，找出下坐标的最长上升子序列长度

```c++
    for (int i = 0; i < n; i++) {
        int a, b;
        scanf("%d%d", &a, &b);
        q[i].x = a, q[i].y = b;
    }

	sort(q, q + n);

    int res = 0;
    for (int i = 0; i < n; i++) {
        f[i] = 1;
        for (int j = 0; j < i; j++) 
            if (q[j].y < q[i].y) f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);
    }
```



#### [1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)

上升子序列和：对于元素满足从左往右数值递增的次序的子序列的和

思路：

状态表示：`f[i]`

- 所有以第 $i$ 个数结尾的上升子序列值的和
- 最大值

状态计算：

- 集合划分依据：当前数 j 是否小于上一个数 i，是则构成上升子序列

    答案可以更新成 本身 和 与 j 构成的的子序列 中和较大的那一个

    `f[i] = max(f[i], f[j] + w[i]),j = 0,1,2,...,i - 1 `

```c++
    for (int i = 1; i <= n; i++) {
        f[i] = a[i];
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i]) f[i] = max(f[i], f[j] + a[i]);
        }
        res = max(res, f[i]);
    }
```



#### [1010. 拦截导弹](https://www.acwing.com/problem/content/1012/)

条件1：数组的最长不上升子序列

条件2：数组最少能被几个最长不上升子序列全部覆盖	→	贪心

思路：

条件要求我们用最少的最长下降子序列对原数组进行全覆盖

贪心：对于第 $i$ 个数来说，把它加入前 $i - 1$ 个数构成的下降子序列组中，所有结尾元素大于第 $i$ 个数的数中最小的那个数

情况1：如果现有的子序列的结尾都小于当前数，则创建新子序列

情况2：将当前数放到结尾大于等于它的最小的子序列后面

（注：求不上升子序列的个数可以转化为求最长上升子序列长度）

```c++
  	for (int i = 0; i < n; i++) {
        f[i] = 1;
        for (int j = 0; j < i; j ++ )
            if (h[i] <= h[j])
                f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);       
 
        // 使用一个队列记录每一个序列中的最小值
        // 每次新的数先从里面找到第一个大于等于它的值接在后面 (更新该序列的值)
        // 如果没有 则要新开一个位置 存储新的序列
        int k = 0;
        while (k < cnt && q[k] < h[i]) k++;	// 如果小则往后寻找
        if (k == cnt) q[cnt++] = h[i];
        else q[k] = h[i];
    }
    // 第二种做法 转化为求最长上升子序列长度
    q[0] = -2e9;
    for (int i = 0; i < n; i++) {
        int l = 0, r = cnt;			
        // eg: 2 1 5 4 3 9 8 7 	2
        // 序列只记录 1(21) 3(543) 7(987) 2属于543序列
        while (l < r) {             // 找到第一个大于等于 a[i] 的数
            int mid = l + r >> 1;
            if (q[mid] >= h[i]) r = mid;
            else l = mid + 1;
        }
        if (q[r] < h[i]) r++;       // 处理边界，当没有能够满足当前高度的系统时，再开一个
        cnt = max(cnt, r);
        q[r] = h[i];
    }
```



#### [187. 导弹防御系统](https://www.acwing.com/problem/content/189/)

拦截导弹的扩展

先行条件：把当前元素加入到 **上升子序列** 还是 **下降子序列**

解决方式：DFS爆搜，暴力枚举

(记录全局最小值 或者 迭代加深)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 55;

int n;
int a[N];

int up[N], down[N];		// 上升序列记录每个序列最大值，整个序列单调递减
int res;				// 下降序列记录每个序列最小值，整个序列单调递增

// 三个参数分别是考虑前u个导弹
// 已经采用了上升系统个数up
// 和下降系统个数down
void dfs(int u, int su, int sd) {
    // 如果已经超过了最优解答案，那么直接剪枝
    if (su + sd >= res) return;

    // 没有超过最优解答案，且把所有导弹都考虑到了
    // 那他就是当前最优解了
    if (u == n) {
        res = su + sd;
        return ;
    }
    
    // 情况1：将当前数放到上升子序列中
    int k = 0;								// 如果大于等于则往后寻找
    while (k < su && up[k] >= q[u]) k++;    // 找到第一个比q[u]小的数
    int t = up[k];
    up[k] = q[u];
    if (k < su) dfs(u + 1, su, sd);
    else dfs(u + 1, su + 1, sd);
    up[k] = t;
    
    // 情况2：将当前数放到下降子序列中
    int k = 0;								// 如果小于等于则往后寻找
    while (k < sd && down[k] <= q[u]) k++;  // 找到第一个比q[u]大的数
    int t = up[k];
    up[k] = q[u];                           // 更新这个序列的最小值（如果是新序列说明 k = su)
    if (k < su) dfs(u + 1, su, sd);         // k < su说明是没有新的序列
    else dfs(u + 1, su + 1, sd);            // 否则序列数加一
    up[k] = t;
}

int main() {

    while (cin >> n && n) {
        for (int i = 0; i < n; i++) cin >> a[i];  
        res = n;  
        dfs(0, 0, 0);    
        cout << res << endl;
    }
    return 0;
}
```





#### [272. 最长公共上升子序列](https://www.acwing.com/problem/content/274/)

**状态表示：**`f[i][j]`

- 集合：所有有第一个序列的前 i 个字母，第二个序列的前 `j` 个字母构成的，且以 b[j] 结尾的公共上升子序列
- 属性：最大值

**状态计算：**

- 集合划分依据：公共子序列包不包含 a[i]

    1. 所有不包含a[i] 的公共上升子序列	`f[i - 1][j]`

    2. 所有包含 a[i] 的公共上升子序列	 

        因为序列包含 b[j] 所以有 a[i] == b[j]，再划分倒数第二个数从 b[1] - b[j-1]

        $f[i][k] + 1 , 0 ≤ k ≤ j-1$

```c++
for (int i = 1; i <= n; i++) {
   	for (int j = 1; j <= n; j++) {
     	f[i][j] = f[i - 1][j];
        if (a[i] == b[j]) {
        	f[i][j] = max(f[i][j], 1);
           	for (int k = 1; k < j; k++) {
         		if (b[k] < b[j])
     				f[i][j] = max(f[i][j], f[i-1][k] + 1);
          	}
		}
   	res = max(res, f[i][j]);
	}
}
```

优化版本：

对于第二种状态转移：$f[i][j] = max(f[i][j], f[i-1][k]+1), 1≤k≤j-1$

每次用到的状态都是 $i-1$ 阶段的

因此可以用一个变量，存储上一个阶段能够在 $a[i]$ 前面的最大状态值

$maxv$ 是满足 $a[i] > b[k]$ 的 $f[i-1][k] + 1$ 的前缀最大值

直接将 $maxv$ 提到第一层循环外面，减少重复计算，此时只剩下两重循环。

```c++
for (int i = 1; i <= n; ++ i) {
  	int maxv = 1;
	for (int j = 1; j <= n; ++ j) {
 		f[i][j] = f[i - 1][j];
    	if (b[j] == a[i]) f[i][j] = max(f[i][j], maxv);
 		if (b[j] < a[i]) maxv = max(maxv, f[i - 1][j] + 1);
        res = max(res, f[i][j]);
	}
}
```





## 背包问题

当空间优化成一维后，只有完全背包问题的体积是从小到大循环的

三层循环：1.物品 2. 体积 3. 决策



### **初始化**

#### 求最大值最小值初始化总结

**一维情况：**

- 体积至多 `j`，`f[i] = 0`, `0 <= i <= m`（只会求价值的最大值）
- 体积恰好 `j`，
    - 当求价值的最小值：`f[0] = 0`, 其余是 `INF`
    - 当求价值的最大值：`f[0] = 0`, 其余是 `-INF`
- 体积至少 `j`，`f[0] = 0`，其余是 `INF`（只会求价值的最小值）

**二维情况：**

- 体积至多 `j`，`f[i][k] = 0`, `0 <= i <= n, 0 <= k <= m`（只会求价值的最大值）

    `f[0][k]`：表示一件物品不选情况下，体积最多是 `k` 的最大价值 ，所有的什么都不选最大价值就是0

- 体积恰好 `j`，（体积恰好，只有 `f[0][0]=0` 是合法的，其余的都是不合法的）

    - 当求价值的最小值：`f[0][0] = 0`, 其余是 `INF`		$(v ≥ 0)$
    - 当求价值的最大值：`f[0][0] = 0`, 其余是 `-INF`

- 体积至少 `j`，`f[0][0] = 0`，其余是 `INF` (v没有≥0的限制)（只会求价值的最小值）



#### 求方案数初始化总结

**一维情况：**

- 体积至多 `j`，`f[i] = 1`, `0 <= i <= m`
- 体积恰好 `j`，`f[0] = 1`，其余是 `0`
- 体积至少 `j`，`f[0] = 1`，其余是 `0`

**二维情况：**

- 体积至多 `j`，`f[0][i] = 1`, `0 <= i <= m`，其余是 `0`
- 体积恰好 `j`，`f[0][0] = 1`，其余是 `0`
- 体积至少 `j`，`f[0][0] = 1`，其余是 `0`





### 01背包

#### [模板题](https://www.acwing.com/problem/content/2/)

**特点：**每件物品最多只用一次

N件物品，容量为V的背包。每件物品只能用一次。



**状态表示：**$f[i][j]$

- 集合：所有只从前 $i$ 个物品中选，且总体积不超过 $j$ 的选法的集合
- 属性：Max

**状态计算：**

- 集合的划分：第 $i$ 个物品是否选，选 和 不选 （不重复不遗漏）

    - 不选第 $i$ 个物品的所有方案	$f[i-1][j]$

    - 选第 $i$ 个物品的所有方案 $f[i-1][j-v_i]+w[i]$

        每个方案都是分为两个部分 第 $i$ 个前面的 和 第 $i$ 个

        左边的选法总体积要小于 $j-v_i$ $f[i-1][j-v_i]$，右边 $w[i]$

```c++
// 二维：
   for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++) {
            f[i][j] = f[i-1][j];	// 默认装不下第i个物品
            // 能装，需进行决策是否选择第i个物品
            if(j>=v[i]) f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i]);
        }
// 一维：
    for(int i = 1; i <= n; i++) 
        for(int j = m; j >= v[i]; j--) 	// 逆序，这里判断j和v[i]的关系 若超过直接退出该轮
            f[j] = max(f[j], f[j-v[i]]+w[i]);
```



#### [423. 采药](https://www.acwing.com/problem/content/425/)

**题目描述：**

题目给定 $n$ 株草药 和 $m$ 位时间

接着给定每株草药如果被采集，所需要的时间 $v$，以及该草药的价值 $w$ 

让我们求出一种采药 **方案** ，在给定的时间 $m$ 内，能够采集到的草药的 **最大价值**

**分析：**

我们把 $m$ 个单位时间看做是 背包的容量

每株草药看做是物品 ，草药采集所需时间看做是 **物品的体积**，草药的价值看做是 **物品的价值**

那么本题就可以看做是一个 **背包问题** 了

由于每株草药只有一个，也就是要么采，要么不采两种方案，所以该题是一个 **01背包** 模型

```c++
    for(int i = 1; i <= n; i++) 
        for(int j = m; j >= v[i]; j--) 
            f[j] = max(f[j], f[j-v[i]]+w[i]);
```



#### [1024. 装箱问题](https://www.acwing.com/problem/content/1026/)

**题目描述：**

题目给定一个容量为 $m$ 的箱子，以及 $n$ 个物品

每个物品 $i$ 有一个体积 $v_i$

要求我们找出一个装箱方案，使得箱子的剩余空间最小

**分析：**

本题也是一个 **01背包** 的题目

一共有 $n$ 个物品，$m$ 的容量，每个物品有一个体积 $v_i$

而题目没有直接给出物品的 **价值**，但是题目要求我们选择物品的时候，在 **体积不超过容量** 的情况下 **最大**

体积减少的同时，空隙也变小了，也不相应的因此我们可以抽象出来物品的 **价值$w_i$** 就是物品的 **体积 $v_i$**

```c++
    for (int i = 1; i <= n ; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] =  max(f[j], f[j - v[i]] + v[i]);
```



#### [278. 数字组合](https://www.acwing.com/problem/content/280/) (方案数)

**01背包求方案数**

**题目描述：**

给定 $N$ 个正整数 $A_1,A_2,…,A_N$，从中选出若干个数，使它们的和为 $M$，求有多少种选择方案。

**分析：**

对于本题我们可以把每个 **正整数** 看作是一个 **物品**

**正整数** 的 **值** 就是 **物品** 的 **体积**

我们方案选择的 目标 是最终 体积 **恰好**为 $m$ 时的 **方案数**

**状态表示：**$f[i][j]$

- 集合：所有只从前 $i$ 个物品中选，且总体积 **恰好为 $j$** 的选法的集合
- 属性：集合的个数
- 恰好为 $j$ ，所以初始化$f[0][0] = 1$

**状态计算：**

- 集合的划分：第 $i$ 个数是否选，选 和 不选 （不重复不遗漏）

    - 不选第 $i$ 个物品的所有方案	$f[i-1][j]$

    - 选第 $i$ 个物品的所有方案 $f[i][j]+=f[i-1][j-v_i]$


```c++
// 二维
	f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i-1][j];
            if (j >= v[i]) f[i][j] += f[i-1][j-v[i]];
        }
// 一维
	f[0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] += f[j - v[i]];    
```



#### [426. 开心的金明](https://www.acwing.com/problem/content/428/)

题目描述：

题目给定 $n$ 个物品，每个物品 $i$ 有一个花费 $v_i$，及其重要程度（价值）

要求在不超过 $m$ 价值的情况下，使得价值最大

标准01背包问题：

```c++
for (int i = 1; i <= n; i++) 
    for (int j = m; j >= v[i]; j--) 
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```





### 二维01背包

#### [模板题](https://www.acwing.com/problem/content/8/)

**题目描述：**

有 $N$ 件物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。

每件物品只能用一次。体积是 $v1_i$，重量是 $v2_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。

**分析：**

状态表示：$f[i][j][k]$

- 集合：所有只从前 $i$ 个物品中选，并且总体积不超过 $j$，总重量不超过 $k$ 的选法
- 属性：最大值

状态计算：

- **集合划分依据：**第 i 个物品是否选，选 和 不选 （不重复不遗漏）

    `f[i][j] = max(f[i-1][j][k], f[i-1][j-v1[i]][k-v2[i]] + w[i]);`

```c++
    for (int i = 1; i <= n; i++)
        for (int j = v; j >= v1[i]; j--)
            for (int k = m; k >= v2[i]; k--)
                f[j][k] = max(f[j][k], f[j - v1[i]][k - v2[i]] + w[i]);
```



#### [1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/1024/)

**题目描述：**

题目给定 $n$ 个精灵 、 $m$ 个精灵球 、$t$ 滴血量

接着给定每个精灵如果被收复，所需要的精灵球 $v1$，以及己方减少的血量 $v2$ 

让我们求出一种收集 **方案** ，在给定的精灵球 $m$ 和血量 $t$内，能够收集到精灵的 **最大数量** 以及 **剩余血量**

**分析：**

本题是一道 01背包 的扩展题 —— **二维费用01背包问题**

可以把精灵看作物品，收复所需要的 **精灵球** 就是 **第一费用**，**减少的血量** 就是 **第二费用**

每个精灵的价值为 $1$ ，要求物品数量最多

```c++
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v1[i]; j--)
            for (int k = t - 1; k >= v2[i]; k--)
                f[j][k] = max(f[j][k], f[j - v1[i]][k - v2[i]] + 1);

// 最小耗费体力 枚举k f[m][k] == f[m][t-1]  记录消耗最少的体力 cost
// 剩余体力 = t - cost
```



#### [1020. 潜水员](https://www.acwing.com/problem/content/1022/) 

**题目描述：**

一共有 $k$ 种 **物品**，对于第 $i$ 种物品，第一维 **费用** 是 ${v1}_i$，第二维 **费用** 是 ${v2}i$，**价值** 是 $w_i$

每个物品只能 **被选一次**

求一个 **选择方案**，使得第一维费用 **不少于 $n$**，第二维费用 **不少于 $m$** 且 **总价值最小**

状态表示：$f[i][j][k]$

- 集合：所有只从前 $i$ 个物品中选，并且总体积不小于 $j$，总重量不小于 $k$ 的选法
- 属性：方案总价值最小
- 在计算 **最小值** 时候，需要把状态记录成 **无穷大**，$f[0][0] = 0$

状态计算：

- **集合划分依据：**第 i 个物品是否选，选 和 不选 （不重复不遗漏）

    `f[i][j] = min(f[i-1][j][k], f[i-1][j-v1[i]][k-v2[i]] + w[i]);`

题目求的是体积要求不少于多少，也就是说当有体积比需要的体积大的物品还是能用得到

例如：$f[3][5]$，至少需要 $3$ 个体积，$5$ 个重量，求能拿到价值的最小值，现在只有一个物品，体积是 $4$，重量是 $4$，价值 $w$，它说至少需要 $3$ 个体积，那么体积是 $4$ 还是可以用到，只是多了 $1$ 个体积没用占着而已，不影响其价值。因此若用了这个物品，则变成了求 $f[0][1] + w$，表示体积已经不再需求了，只需要 $0$ 个体积即可

```c++
    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = n; j >= 0; j--)		
            for (int k = m; k >= 0; k--)	
                f[j][k] = min(f[j][k], f[max(j-v1[i], 0)][max(k-v2[i], 0)]+w[i]);
```







### 完全背包

#### [模板题](https://www.acwing.com/problem/content/3/)

**特点：**每件物品有无限个

N件物品，容量为V的背包。每件物品能用多次

**分析：**

**状态表示：**$f[i][j]$

- 集合：所有只从前 $i$ 个物品中选，且总体积不超过 $j$ 的选法的集合
- 属性：Max

**状态计算：**

- 集合的划分：第 $i$ 个物品选多少个，选0个，选1个、选2个、··· 、选k个
    - $f[i][j] = max(f[i][j], f[i - 1][j - k * v_i] + k * w_i),(1-k)*v_i<=j$
    - 优化：$f[i][j] = max(f[i-1][j],f[i][j]-v_i+w_i)$

优化过程：

`f[i][j]   = max(f[i-1][j], f[i-1][j-v[i]]+w[i], f[i-1][j-2*v[i]]+2*w[i], f[i-1][j-3*v[i]]+3*w[i],···`

`f[i][j-v] = max(           f[i-1][j-v[i]],      f[i-1][j-2*v[i]]+w[i],	 f[i-1][j-3*v[i]]+2*w[i],···`

`f[i][j]   = max(f[i−1][j], f[i][j−v[i]] + w[i])`

```c++
// 原始
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++)
            for (int k = 0; k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
// 优化时间
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }
// 优化空间
// 转移方程 对于第 i 阶段的状态，只会使用第 i-1 层和第 i 层的状态
for (int i = 1; i <= n; i++)
    for (int j = v[i]; j <= m; j++)
  		f[j] = max(f[j], f[j - v[i]] + w[i]);
```





#### [1023. 买书](https://www.acwing.com/problem/content/1025/) (方案数)

**完全背包求方案数**

**题目描述：**

小明有 $m$ 块钱，现有 10 元， 20 元， 50 元， 100 元 的书

每本书可以**购买多次**，求小明有多少种买书**方案**

**分析：**

一共有 $n$ 个物品，每个物品都有体积 $v_i$，价值 $w_i$，每个物品能够 **选多次**

求总体积不超过 $m$ 的 **方案数**

**状态表示：**$f[0][0]$

- 集合：考虑前 $i$ 个物品，且总体积恰好是 $j$ 的选法的集合
- 属性：集合的个数
- 方案数总体积恰好 $j$ ，所以初始化$f[0][0] = 1$

**状态转移：**

- 集合的划分：第 $i$ 个物品选多少个，选0个，选1个、选2个、··· 、选k个

    $f[i][j] += f[i - 1][j - v[i] * k]$  		$v_i*k≤j$

    优化：

    $f[i][j]=f[i-1][j]$ 		

    $if(j >= v[i])$，$f[i][j] += f[i][j - v_i]$

```c++
// 原始
    f[0][0] = 1;
    for (int i = 1; i <= n; ++ i)
        for (int j = 0; j <= m; ++ j)
            for (int k = 0; v[i] * k <= j; ++ k)
                f[i][j] += f[i - 1][j - v[i] * k];
// 优化时间
    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i-1][j];
            if (j >= v[i]) f[i][j] += f[i][j-v[i]];
        }
// 优化空间	
	f[0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = v[i]; j <= m; j++)
            f[j] += f[j - v[i]];
```



#### [1021. 货币系统](https://www.acwing.com/problem/content/1023/)(方案数)

题目描述：

给定 $n$ 种面值的货币，每种货币可以选无数个

问：组成面值为 $m$ 的货币共有多少种方案

分析：

题目与买书一样，都是完全背包问题

一共有 n一共有 $n$ 个物品，每个物品都有体积 $v_i$，价值 $w_i$，每个物品能够 **选多次**

求总体积不超过 $m$ 的 **方案数**

```c++
    f[0] = 1;
    for (int i = 1; i <= n; i++) 
        for (int j = v[i]; j <= m; j++)
            f[j] += f[j - v[i]];
```



#### [532. 货币系统](https://www.acwing.com/problem/content/534/)(方案能否满足)

题目描述：

[完全背包求解最大无关向量组个数](https://www.acwing.com/solution/content/53198/)

分析：

**状态表示：**$f[i][j]$

- 集合：考虑前 $i$ 个物体，当前体积为 $j$ 的方案
- 属性：方案能否被满足

**状态转移：**

- 集合划分的依据：第 $i$ 个物品选多少个，选0个，选1个、选2个、··· 、选k个

    这里转移不是求方案数，而且方案能否满足，所以用异或

    $f[i][j] |= f[i-1][j]，f[i-1][j-v_i],...,f[i-1][j-kv_i]$

```c++
// 数组先排序，最后一个元素是背包容积
   	int m = v[n], res = 0;
  	f[0] = true;	// 状态的初值
    for (int i = 1; i <= n; i++) {
        //如果当前物品体积被之前的物品组合线性筛掉了，则它是无效的
        if (f[v[i]]) continue;
        res ++ ;	// 如果没有被筛掉，则把它加入最大无关向量组
        for (int j = v[i]; j <= m; ++ j) {
        f[j] |= f[j - v[i]];			// 筛掉当前最大无关向量组能线性表示的体积
        }
    }
```





### 多重背包

#### [模板题](https://www.acwing.com/problem/content/4/)

**特点：**每个物品限定多少个

N件物品，每件物品分别有S个，容量为V的背包。每件物品能用多次

**分析：**

**状态表示：**$f[i][j]$

- 集合：所有只从前 $i$ 个物品中选，且总体积不超过 $j$ 的选法的集合
- 属性：Max

**状态计算：**

- 集合的划分：第 $i$ 个物品选多少个，选0个，选1个、选2个、··· 、选k个

    状态表示与完全背包朴素代码一样均为：

    - $f[i][j] = max(f[i][j], f[i - 1][j - k * v_i] + k * w_i),(1-k)*v_i<=j,k<=s_i$
    - 优化：$f[i][j] = max(f[i-1][j],f[i][j]-v_i+w_i)$



完全背包：求所有前缀的最大值

多重背包：求滑动窗口内的最大值

```c++
int v[N], w[N], s[N]; // 物品的体积，价值，数量
// 原始
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)		// 一般可以从 1 开始, 方案数需要从0开始
        for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
            f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
// 优化空间
for (int i = 1; i <= n; i++)
	for (int j = m; j >= v[i]; j--) 
		for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
			f[j] = max(f[j], f[j - v[i] * k] + w[i] * k);

```

##### 二进制优化

```c++
// 二进制优化		二进制枚举 1 2 4 ... 64 可以凑出 0-128 所有数
    for (int i = 1; i <= n; i++) {
        for (int k = 1; k <= s[i]; k *= 2) {   
            for (int j = m; j >= k * v[i]; j--) {
                f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
            }
            s[i] -= k;
        }
        if (s[i]) {		// 剩余的按照01背包解决
            for (int j = m; j >= s[i] * v[i]; j--) 
                f[j] = max(f[j], f[j - s[i] * v[i]] + s[i] * w[i]);
        }
    }
```

##### 滑动窗口优化

```c++
// 优化	滑动窗口只是减少第三层循环
// 滑动窗口内的最大值
    for (int i = 1; i <= n; ++ i) 
        // r=背包容积j除以物品体积v的余数
        // 用 r, r +vi, r + 2vi, r + 3vi, … ,j - vi, j枚举背包容积
        for (int j = 0; j < v[i]; j++) {	
            int hh = 0, tt = -1;	
            for (int k = j; k <= m; k += v[i]) {     // 枚举价值 每次多放一个  
            
                // s * v是滑动窗口的长度
                // q存放的是窗口内单调递减的元素的下标，队头元素是窗口内最大的元素的值的下标
                // 比如当前维护队列内有两个元素，且f[i][j - v] + w > f[i][j - 2v]
                // 那么队头元素q[hh] = j - v而第二个元素q[hh + 1] = j - 2v
                if (hh <= tt && k - q[hh] > s[i] * v[i]) hh ++ ;    // 判断是否划出窗口

                //（k-q[tt]) / v[i] * w[i] = 空间 / 每件容量 * 单件价值 = 个数 * 价值 = 总价值
                // 之前轮次能放的总价值 比 当前轮次放的少 
                // 说明当前轮次更有用，把上一轮次删除记录更靠近后面且更大的值
                while (hh <= tt && f[i - 1][q[tt]] + (k - q[tt]) / v[i] * w[i] <= f[i - 1][k]) tt--;
                q[ ++ tt] = k;      // 更新队尾
                
                // 跟新f[i][k]
                f[i][k] = f[i - 1][k];  // 不放物品i
                if (hh <= tt) 			// 放物品i         // 放
                    f[i][k] = max(f[i][k], f[i - 1][q[hh]] + (k - q[hh]) / v[i] * w[i]); 
                    // 放物品i的值等于滑窗内不放物品i的值 + 剩余全放物品i的值
        	}
        }
```



#### [1019. 庆功会](https://www.acwing.com/problem/content/1021/)

**题目描述：**

一共有 $n$ 种奖品，$m$ 元现金

对于第 $i$ 种奖品，其 **价格** 为 $v_i$，**价值** 为 $w_i$，**数量** 为 $s_i$

制定一个购买 **方案**，使得该方案的总价值 **最大**

**分析：**

标准的多重背包问题，根据数据范围用朴素版模板

```c++
// 原始
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
// 优化空间
	for (int i = 1; i <= n; i++)
		for (int j = m; j >= v[i]; j--) 
			for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
				f[j] = max(f[j], f[j - v[i] * k] + w[i] * k);
```





#### [获得分数的方法数](https://leetcode.cn/problems/number-of-ways-to-earn-points/) (方案数)

考试中有 `n` 种类型的题目。给你一个整数 `target` 和一个下标从 **0** 开始的二维整数数组 `types` ，其中 `types[i] = [counti, marksi] `表示第 `i` 种类型的题目有 `counti` 道，每道题目对应 `marksi` 分。

返回你在考试中恰好得到 `target` 分的方法数。由于答案可能很大，结果需要对 `109 +7` 取余。

**分析：**

 `n` 种物品中，其中每个物品有 `s[i]` 个，体积为 `v[i]`，价值为 `w[i]` ，求恰好价值 `m` 的方案数

多重背包问题：其中物体个数为 `types.size()`，每个物品有 `s=types[i][0]` 个，价值和体积为 `v=w=types[i][1]`

```c++
	int n = types.size();
	int m = target;

// 二维
    f[0][0] = 1;	// 恰好 初始化f[0][0]
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++) {
            int s = types[i - 1][0], v = types[i - 1][1];
            for (int k = 0; k <= s && k * v <= j; k++)
                f[i][j] = (f[i][j] + f[i - 1][j - k * v]) % mod ;
        }

// 一维
	f[0] = 1;	// 求方案数记得初始化
    for (int i = 1; i <= n; i++) {
        int s = types[i - 1][0], v = types[i - 1][1], w = types[i - 1][1];
        for (int j = target; j >= v; j--) 
            for (int k = 1; k <= s && k * v <= j; k++) {	// 一维倒序，求方案数
                f[j] = (f[j] + f[j - v * k] ) % mod ;		// k如果从0开始，会出现f[j]+f[j]重复
            }        
    }
```





### 分组背包

#### [模板题](https://www.acwing.com/problem/content/9/)

**特点：**每组最多选一个

$N$ 组物品，每组物品分别有 $S$ 个，容量为 $V$ 的背包。每组物品最多选一个

**分析：**

**状态表示：**$f[i][j]$

- 集合：所有只从前 $i$ 组物品中选，且总体积不超过 $j$ 的选法的集合

    每一组物品有若干个，同一组物品最多选一个

- 属性：Max

**状态计算：**

- **集合划分依据：**枚举第 i 组物品选哪个，不选、选第 1 个 ··· 选第 k 个。

    $f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i][k]] + w[i][k])$

```c++
int v[N][N],w[N][N],s[N];   // v为体积，w为价值，s代表第i组物品的个数
int f[N][N];  // 只从前i组物品中选，当前体积小于等于j的最大值
//二维
    for(int i = 1; i <= n; i++) 
        for(int j = 0; j <= m; j++) {
            f[i][j]= f[i-1][j];  // 不选
            for(int k = 0; k < s[i]; k++) {
                if(j >= v[i][k])     
                    f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);  
            }
        }

// 一维
    for (int i = 1; i <= n; i++) 
    	for (int j = m; j >= 0; j--) 
            for (int k = 0; k < s[i]; k++)
                if (j >= v[i][k])
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```







#### [1013. 机器分配](https://www.acwing.com/problem/content/1015/)

**题目描述：**

总公司拥有 $M$ 台 相同 设备，准备分给下属的 $N$ 个分公司。

第 $i$ 家公司分到 $j$ 台机器后，所获的的收益为 $w_{ij}$

求一种分配方案，使得总收益最大，输出该方案

**分析：**

每家 **公司** 可以看成一个 **物品组** $S$

分配 **机器** 的数量可以看成是 **体积** $V[i][j]$

不同机器下的价值可以看成 **不同物品的价值** $W[i][j]$

于是，本题就转换成了一个 **分组背包问题 + 求具体方案**

**状态表示：**$f[i][j]$

- 集合：从前 $i$ 个物品组中选，且总体积不超过 $j$ 的选法的集合
- 属性：最大值

**状态计算：**

**集合划分依据：**枚举第 i 组物品选哪个，不选、选第 1 个 ··· 选第 k 个。

- $f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i][k]] + w[i][k])$
- $f[i][j] = max(f[i - 1][j], f[i - 1][j - k] + w[i][k])$

```c++
// 初始化 v[i][k] = k   s[i] = j 
	for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &w[i][j]);

// 多重背包
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            f[i][j] = f[i - 1][j];
            for (int k = 0; k <= j; k++)
                f[i][j] = max(f[i][j], f[i-1][j-k] + w[i][k]);   
            // for(int k = 0; k < s[i]; k++)  每堆都能取到j个 s[i] = j 所以k<j
            	// if(j >= v[i][k]) 		  v[i][k] = k  k <= j 所以去掉
        }

// 求方案数
    int j = m;
    for (int i = n; i; i--) {				// 倒着枚举
        for (int k = 0; k <= j; k++) {		// 因为多重背包可能会选0-j(s[i])件 枚举
            if (f[i][j] == f[i-1][j-k] + w[i][k]) {
                way[i] = k;
                j -= k;						// 第i个物品取k件
                break;						// 取完第i个物品退出单层循环
            }
        }
    }
```



#### [487. 金明的预算方案](https://www.acwing.com/problem/content/489/)

可以将每个主件及其附件看作一个物品组，记主件为 $p$，两个附件为 $a,b$，则最多一共有4种组合：

1. p
2. p, b
3. p, b
4. p, a, b

这四种组合是互斥的，最多只能从中选一种，因此可以将每种组合看作一个物品，那么问题就变成了分组背包问题。可以参考AcWing 9. 分组背包问题。

在枚举四种组合时可以使用二进制的思想，可以简化代码。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

#define v first
#define w second

using namespace std;

typedef pair<int, int> PII;

const int N = 70, M = 32010;

int n, m;
PII master[N];          // 主物品
vector<PII> servent[N]; // 附件，第q个物品的所有附件
int f[M];

int main() {
    cin >> m >> n;
    for (int i = 1; i <= n; i++) {
        int v, p, q;
        cin >> v >> p >> q;
        p *= v;
        if (!q) master[i] = {v, p};
        else servent[q].push_back({v, p});
    }
    
    for (int i = 1; i <= n; i++)        // 枚举物品
        for (int u = m; u >= 0; u--) {  // 枚举体积
            
            // 二进制枚举，列举所有的分组背包内的物品
            // 1 << 2 == 100(2进制), 其中包含了00,01,10,11这三种情况
            // 可以用这四种情况判断用了哪些物品
            for (int j = 0; j < 1 << servent[i].size(); j ++ ) {
                int v = master[i].v, w = master[i].w;		// 主物品的值
                 for (int k = 0; k < servent[i].size(); k ++) {
                    if (j >> k & 1) {
                        v += servent[i][k].v;
                        w += servent[i][k].w;
                    }
                }   // 如果背包体积大于物品体积 更新
                if (u >= v) f[u] = max(f[u], f[u - v] + w);
            }
        }
        
    cout << f[m] << endl;

    return 0;
}
```



### 混合背包

[7. 混合背包问题](https://www.acwing.com/problem/content/7/)

题目描述：

有 $n$ 种物品和一个 容量 为 $m$ 的背包，物品分三类：

1. 第一类物品只能用 1 次（01背包）；
2. 第二类物品可以用无限次（完全背包）；
3. 第三类物品最多只能用 $s_i$ 次（多重背包）；

每种体积是 $v_i$，价值是 $w_i$

求解一个选物品的方案，是的物品 总体积 不超过背包的 容量，且 总价值最大

分析：

**状态表示：**$f[i][j]$

- 集合：从前 $i$ 个物品组中选，且总体积不超过 $j$ 的选法的集合
- 属性：最大值

**状态计算：**

**集合划分依据：**根据当前物品是哪类背包，做相应的状态转移

- 01背包
- 完全背包
- 多重背包

```c++
int v[N], w[N], s[N]; // 物品的体积，价值，数量
// 01背包
for (int i = 1; i <= n; i++)
    for (int j = m; j >= v[i]; j--)
     	f[j] = max(f[j], f[j - v[i]] + w[i]);
// 完全背包
for (int i = 1; i <= n; i++)
    for (int j = v[i]; j <= m; j++)
        f[j] = max(f[j], f[j - v[i] + w[i])
// 多重背包		01背包是特殊的多重背包
for (int i = 1; i <= n; i++)
	for (int k = 1; k <= s[i]; k *= 2) {
        for (int j = m; j >= k * v[i]; j--)
            f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
        s[i] -= k;
    }
	if (s[i]) {
        for (int j = m; j >= s[i] * v[i]; j--)
            f[j] = max(f[j], f[j - s[i] * v[i]] + s[i] * w[i]);
    }
```

```c++
    for (int i = 1; i <= n; i++) {
        if (s[i] == 0) {
            for (int j = v[i]; j <= m; j++)
                f[j] = max(f[j], f[j - v[i]] + w[i]);
        } else {
            if (s[i] == -1) s[i] = 1;
            for (int k = 1; k <= s[i]; k *= 2) {
                for (int j = m; j >= k * v[i]; j--)
                    f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
                s[i] -= k;
            }
            if (s[i]) {
                for (int j = m; j >= s[i] * v[i]; j--)
                    f[j] = max(f[j], f[j - s[i] * v[i]] + s[i] * w[i]);
            }
        }
    }
```





### 有依赖的背包问题

[10. 有依赖的背包问题](https://www.acwing.com/problem/content/10/)

题目描述：

有 $N$ 件物品和一个体积为 $V$ 的背包，第 $i$ 件物品的体积为 $v_i$，价值为 $w_i$

每件物品有一个父节点物品 $p_i$，如果想选第 $i$ 件 物品，就必须选他的父节点 $p_i$

求一个方案，使得该选择的物品合法，总体积不超过 $V$，且总价值最大

分析：

这是树形DP+完全背包问题

以往 线性背包DP 的 状态转移，第 $i$ 件 物品 只会依赖第 $i−1$ 件物品的状态

再枚举体积，最坏时间复杂度可能会达到 $O(N×2N×V)$（所有子节点都依赖根节点），TLE

更换思考方式，枚举每个 状态 分给各个子节点 的 体积 ，这样时间复杂度就是 $O(N×V×V)$

**状态表示：**$f[i][j]$

- 属性：考虑第 $i$ 个物品为根节点的子树，且选上 $i$ ，选法的总体积不超过 $j$ 的方案
- 集合：最大值

**状态计算：**

- 集合划分的依据，两大类：不考虑第 $i$ 个物品和考虑第 $i$ 个物品

    其中考虑第 $i$ 个物品，可以细分成是否选择第 $k$ 个子节点 $f[son_{s_k},j]$

```c++
void dfs(int u) {
    for (int i = h[u]; ~i; i = ne[i]) { // 遍历所有子树
        int son = e[i];
        dfs(son);      // 递归子树,从下往上算，先计算子节点的状态
        for (int j = m - v[u]; j >= 0; j--)     // 枚举所有要被更新的状态
            for (int k = 0; k <= j; k++)        // 枚举该子节点在体积j下能使用的所有可能体积数
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    } 
    // 最后选上第u件物品
    for (int j = m; j >= v[u]; j--) f[u][j] = f[u][j - v[u]] + w[u];
    for (int j = 0; j <  v[u]; j++) f[u][j] = 0;   //清空没选上u的所有状态
}
```







### 求具体方案

[12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/)

求背包问题的 **具体方案** 其实就是求输出方案的 **转移路径**

先做一遍正常的背包DP，然后从 **目标状态** 倒推回 **初始状态** 的整个 **转移路径** 即可

即：在考虑第 $i$ 件物品时候，选择了 **选** 还是 **不选** 的策略到达了第 $i+1$ 件物品

**注意：**求具体方案数要使用二维空间

**伪代码：**

```c++
int v = V;  // 记录当前的存储空间

// 二维DP

// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环
for (从最后一件循环至第一件) {
  if (j >= v[i] && f[i][j] == f[i-1][j-v[i]]+w[i]) {
    选了第 i 项物品;
    j -= 第 i 项物品的价值;
  } else
    未选第 i 项物品;
}
```



**要求输出字典序最小的方案**

而在倒推 **状态转移路径** 的时候，只能在 **分叉转移** 的时候，即 **当前** 物品既可以 **选** 又可以 **不选** 时，优先 **选**

因此， **背包DP** 需要倒过来**（从N递推到1）**做，然后再 **从1倒推回N 找出路径**

这样在抉择时，如果出现 **分叉转移**，我们就优先 **选** 当前物品即可

```c++
	for (int i = n; i; i--) 
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i+1][j-v[i]]+w[i]);
        }
	int j = m;
	for (int i = 1; i <= n; i++)
        if (j >= v[i] && f[i][j] == f[i+1][j-v[i]]+w[i]) {
            cout << i << ' ';
            j -= v[i];
        }
```



### 背包问题求方案数

题目描述：

有 $N$ 件 物品 和一个 容量 为 $V$ 的背包。每件 物品 只能使用 一次 

第 $i$ 件 物品 的 体积 是 $v_i$，价值 是 $w_i$

求解将哪些物品装入背包，可使 总体积 不超过 $V$ 的情况下， 总价值 最大 

输出 最优选法的方案数 。答案可能很大，输出答案模 $10^9+7$ 的结果

**状态表示：**$g[i][j]$

- 集合：考虑前 $i$ 个物品，当前已使用体积恰好是 $j$ 的，且 价值 为最大的方案
- 属性：方案的数量

**状态计算：**

- 集合划分的依据：考虑前 $i$ 的方案数和 只考虑前 $i-1$ 个物品方案数的关系
    - 如果 `f[i][j]=f[i-1][j]`，且 `f[i][j]=f[i-1][j-v]+w`，则 `g[i][j]=g[i-1][j]+g[i-1][j-v]`
    - 如果 `f[i][j]=f[i-1][j]`，且 `f[i][j]!=f[i-1][j-v]+w`，则 `g[i][j]=g[i-1][j]`
    - 如果 `f[i][j]!=f[i-1][j]`，且 `f[i][j]=f[i-1][j-v]+w`，则 `g[i][j]=g[i-1][j-v]`

```c++
    g[0][0] = 1;	// 初始化方案
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++) {
            if (f[i][j] == f[i - 1][j]) g[i][j] = (g[i][j] + g[i - 1][j]) % mod;
            if (j >= v[i] && f[i][j] == f[i - 1][j - v[i]] + w[i])
                g[i][j] = (g[i][j] + g[i - 1][j - v[i]]) % mod;
        }
    int res = 0;
    for (int j = 0; j <= m; j++) {
        if (f[n][j] == f[n][m]) res = (res + g[n][j]) % mod;
    }
```



## 状态机模型

**所谓的状态机，可以默认为搜索的方向数组，加到了动态规划上面**

**把混沌的状态表示细化**



### [1049. 大盗阿福](https://www.acwing.com/problem/content/1051/)

**题目描述：**

街道上有 $N$ 家店铺，按照顺序从 $1$ 到 $N$ 排好第 $i$ 家店铺的财产是 $w_i$ 大盗阿福

如果偷了第 $i$家店铺，则他 不能偷 相邻的店铺，否则会被抓起来

帮助大盗阿福找出一种偷盗 方案，使得获得的 总财产最大



**常规线性背包分析**

**状态表示：**$f[i]$

- 集合：从前 $i$ 个物品组中选法的集合
- 属性：最大值

**状态计算：**

- **集合划分依据：**第 $i$ 个物品是否选择

- `f[i] = max(f[i-1], f[max(0, i - 2)] + w[i])`



**状态机模型分析：**

**把混沌的状态表示细化**

![打家劫舍状态机模型](https://cdn.acwing.com/media/article/image/2021/07/02/55909_5c79c42cda-IMG_86A570C793B3-1.jpeg)

如果不偷第 $i$ 家店铺，则第 $i-1$ 店铺任意安排：$f[i][0]=max(f[i-1][0],f[i-1][1])$

如果要偷第 $i$ 家店铺，则第 $i-1$ 店铺不能被偷：$f[i][1]=f[i-1][0]+w[i]$

初始状态：$f[0][0]=0,f[0][1]=-INF(表示不合法)$

目标状态：$max(f[n][0],f[n][1])$

```c++
	f[0][0] = 0, f[0][1] = INT_MIN;
	for (int i = 1; i <= n; i++) {
 		f[i][0] = max(f[i - 1][0], f[i - 1][1]);
 		f[i][1] = f[i - 1][0] + w[i];
   	}
        res = max(f[n][0], f[n][1]));
```



### [1055. 股票买卖 II](https://www.acwing.com/problem/content/description/1057/)

**题目描述：**

给定一个长度为 $N$ 的数组 $w$，数组的第 $i$ 个元素 $w_i$ 表示第 $i$ 天的股票 价格

一次买入一次卖出为一笔 **合法交易**，**且不能同时产生多笔** 交易（必须在再次购买前出售掉之前的股票）

设计一个方案，使得总利润 **最大**

状态机模型为：

![股票买卖状态机模型](https://cdn.acwing.com/media/article/image/2021/03/25/55909_688daf5f8d-IMG_4E31C78D0C18-1.jpeg)

**有两种状态：**

- 当前处于 未持股状态0，对应可以进行的转换
    - 0 → 0（不买入，继续观望，那么就什么都不发生）
    - 0 → 1（买入股票，那么收益就要减去当前市场的股票价格）
- 当前处于 持股状态1，对应可以进行的转换
    - 1 → 1（不卖出，继续观望，那么就什么都不发生）
    - 1 → 0（卖出股票，那么收益就要加上当前市场的股票价格）

**状态表示：**$f[i][j]$

- 集合：考虑前 $i$ 天的股市，第 $i$ 天的手中持有股票状态为 $j$ 选法的集合
- 属性：最大值

**状态计算：**

- **集合划分依据：**第 $i-1$ 天是否持股
- $f[i][0]=max(f[i-1][0],f[i-1][1]+w[i])$
- $f[i][1]=max(f[i-1][1], f[i-1][0]-w[i])$

初始状态：$f[0][0]=0,f[0][1]=-INF(表示不合法)$

目标状态：$f[n][0]$

```c++
    f[0][0] = 0, f[0][1] = -INF;	// f[0][1]不合法
    for (int i = 1; i <= n; ++i) {
        f[i][0] = max(f[i - 1][0], f[i - 1][1] + w[i]);
        f[i][1] = max(f[i - 1][1], f[i - 1][0] - w[i]);
    }
```



### [1057. 股票买卖 IV](https://www.acwing.com/problem/content/1059/)

**题目描述：**

给定一个长度为 $N$ 的数组 $w$，数组的第 $i$ 个元素 $w_i$ 表示第 $i$ 天的股票 价格

一次买入一次卖出为一笔 **合法交易**，**且不能同时产生多笔** 交易（必须在再次购买前出售掉之前的股票）

设计一个方案，使得 **总合法交易数** 不超过 $m$ 次，总利润 **最大**

本题比上一题多了交易次数的限制，需要额外加上记录 **当前交易笔数** 的参数，买入算一次交易

![股票买卖4状态机.png](https://cdn.acwing.com/media/article/image/2021/07/02/55909_e2c6226ada-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE-dp-%E7%8A%B6%E6%80%81%E6%9C%BA.png)

**状态表示：**$f[i][j][k]$

- 集合：考虑前 $i$ 天的股市，第 $i$ 天的手中持有股票状态为 $k$ ，且总交易数不超过 $j$ 选法的集合
- 属性：最大值

**状态计算：**

- **集合划分依据：**第 $i-1$ 天是否持股
- $f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i])$
- $f[i][j][1]=max(f[i-1][j][1], f[i-1][j-1][0]-w[i])$

初始状态：

$f[0][0][0]=0,其余=-INF(表示不合法)$

$f[i][0][0]=0,f[i][0][1]=-INF$

目标状态：$max(f[n][j][0]),0≤j≤m$

```c++
    memset(f, -0x3f, sizeof f);						// 不合法方案
    for (int i = 0; i <= n; i++) f[i][0][0] = 0;	// 合法方案
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
        }
    int res = 0;
    for (int j = 0; j <= m; j++) res = max(res, f[n][j][0]);
```



### [1058. 股票买卖 V](https://www.acwing.com/problem/content/1060/)

**题目描述：**

给定一个长度为 $N$ 的数组 $w$，数组的第 $i$ 个元素 $w_i$ 表示第 $i$ 天的股票 价格

1. 一次买入一次卖出为一笔 合法交易，且不能同时产生多笔交易（必须在再次购买前出售掉之前的股票）
2. 卖出股票后，无法在第二天买入股票（冷冻期为1天）

设计一个方案，使得总利润最大

![股票买卖Ⅴ状态机](https://cdn.acwing.com/media/article/image/2021/07/03/55909_f22fdff4db-IMG_5D88B9FE2880-1.jpeg)

1. 如果第 $i$ 天是 **空仓 (j=0)** 状态，则 $i-1$ 天可能是 **空仓 (j=0)** 或 冷冻期 **(j=2)** 的状态
2. 如果第 $i$ 天是 **持仓 (j=1)** 状态，则 $i-1$ 天可能是 **持仓 (j=1)** 状态 或 **空仓 (j=0)** 的状态 （买入）
3. 如果第 $i$ 天是 **冷冻期 (j=2)** 状态，则 $i-1$ 天只可能是 **持仓 (j=1)** 状态，在第 $i$ 天选择了 卖出



**状态表示：**$f[i][j]$

- 集合：考虑前 $i$ 天的股市，第 $i$ 天的手中持有股票状态为 $j$ 选法的集合
- 属性：最大值

**状态计算：**

- **集合划分依据：**第 $i-1$ 天是否持股
- $f[i][0]=max(f[i-1][0],f[i-1][2])$
- $f[i][1]=max(f[i-1][1],f[i-1][0]-w[i])$
- $f[i][2]=f[i-1][1]+w[i]$

初始状态：$f[0][0]=0,f[0][1]=f[0][2]=-INF$

目标状态：$max(f[n][0],f[n][2])$

```c++
    f[0][0] = 0;
    f[0][1] = f[0][2] = -0x3f3f3f3f;
    for (int i = 1; i <= n; i++) {
        f[i][0] = max(f[i - 1][0], f[i - 1][2]);
        f[i][1] = max(f[i - 1][1], f[i - 1][0] - w[i]);
        f[i][2] = f[i-1][1] + w[i];
    }
    res = max(f[n][0], f[n][2]);
```



### [1052. 设计密码](https://www.acwing.com/problem/content/1054/)

**状态表示：**$f[i][j]$

- 集合：表示密码已经生成了 $i$ 位，并且第 $i$ 位匹配到字符串中的位置为 $j$ 时的方案数
- 属性：数量

**状态计算：**

- 集合划分的依据：第 $i + 1$ 位的字母是什么

    当第 $i+1$ 位置是 'a' 时，$f[i][j]$ 能转移道德位置设为 $f[i+1][u]$

    第 $i + 1$ 为匹配到字串中的位置 $u$

    $f[i+1][u]=f[i+1][u]+f[i][h]$

```c++
    // kmp预处理前缀表
    for (int i = 2, j = 0; i <= m; i++) {
        while (j && s[i] != s[j + 1]) j = ne[j];
        if (s[i] == s[j + 1]) j++;
        ne[i] = j;
    }
    f[0][0] = 1;
    for (int i = 0; i < n; i++)        // 枚举密码位
        for (int j = 0; j < m; j++)    // 把第i位密码匹配到的子串位置都枚举一遍
        // j表示第i位密码匹配到的位置,因为不能包含子串,所以不能匹配到m这个位置
            for (char k = 'a'; k <= 'z'; k++) { // 枚举第i+1个字符
        // 匹配过程:寻找当第i+1的位置是k时,并且密码已经生成了第i位,匹配的子串的位置是j时,能跳到哪个位置
                int u = j;      // 计算枚举到第i+1个字符后，后缀匹配的最大长度
                while (u && k != s[u + 1]) u = ne[u];
                if (k == s[u + 1]) u++;
                if (u < m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod;
                // 因为是从f[i][j](i+1的位置为k)跳到f[i+1][u]这个位置
            }
```





## 区间DP模型

#### 模板

所有的区间 dp 问题枚举时，第一维通常是枚举区间长度，$a$ 并且一般 $len = 1$ 时用来初始化，枚举从 $len = 2$ 开始；第二维枚举起点 $i$ （右端点 $j$ 自动获得，$j = i + len - 1$）

**模板代码如下**：

```c++
for (int len = 1; len <= n; len++) {         // 区间长度
    for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点
        int j = i + len - 1;                 // 区间终点
        if (len == 1) {
            dp[i][j] = 初始值
            continue;
        }

        for (int k = i; k < j; k++) {        // 枚举分割点，构造状态转移方程
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]);
        }
    }
}
```



#### [282. 石子合并](https://www.acwing.com/problem/content/284/)

**状态表示：**`f[i, j]`

- 集合：所有将第 i 堆石子到第 j 堆石子合并成一堆石子的合并方式

- 属性：最小值

**状态计算：**

- 集合划分依据：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并
    - `i < j` 时，`f[i][j]=min(f[i][k] + f[k+1][j] + s[j] − s[i−1])  i ≤ k ≤ j - 1`
    - `i = j` 时，`f[i][i]=0` (合并一堆石子代价为 0)

问题答案： `f[1][n]`

```c++
    for (int i = 1; i <= n; i++) s[i] += s[i - 1];  
	memset(f, 0x3f, sizeof f);                  
    // 区间 DP 枚举套路：长度+左端点 
    for (int len = 1; len <= n; len++) {         // len表示[i, j]的元素个数
        for (int i = 1; i + len - 1 <= n; i++) {
            int l = i, r = i + len - 1;          // l r 左右端点
            if (len == 1) {
                f[l][r] = 0;  // 边界初始化
                continue;
            }
            for (int k = l; k < r; k++) {       // 枚举分割点，构造状态转移方程
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
            }
        }
    }
    cout << f[1][n] << endl;
```



#### [1068. 环形石子合并](https://www.acwing.com/problem/content/1070/)

区别：环形的区间DP，第一个和最后一个可以结合

我们可以把链延长两倍，变成 $2n$ 个堆，其中 $i$ 和 $i+n$ 是相同的两个堆，然后直接套 区间DP 模板，但对于 阶段 $len$ 只枚举到 $n$，根据 状态的定义，最终可以得到所求的方案，时间复杂度为 $O(n^3)$

```c++
    for (int i = 1; i <= n; i++) scanf("%d", &w[i]), w[i + n] = w[i];	// 处理输入
    
    for (int i = 1; i <= n * 2; i++) s[i] = s[i - 1] + w[i];			// 前缀和
    
	memset(f, -0x3f, sizeof f);     // f记录最大值 需要置成最小值
    memset(g, 0x3f, sizeof g);      // g记录最小值 需要置成最大值
    for (int len = 1; len <= n; len++) 
        for (int i = 1; i + len - 1 <= n * 2; i++) {
            int l = i, r = i + len - 1;
            if (len == 1) {
                f[l][r] = g[l][r] = 0;
            	continue;
            }
            for (int k = l; k < r; k++) {
                f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
                g[l][r] = min(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]);
            }
       	}
    int minv = INT_MAX, maxv = INT_MIN;
    for (int i = 1; i <= n; i++) {
        minv = min(minv, g[i][i + n - 1]);
        maxv = max(maxv, f[i][i + n - 1]);
    }
```



#### [320. 能量项链](https://www.acwing.com/problem/content/322/)

**状态表示：**`f[i, j]`

- 集合：当前合并的石子堆的左端石头的左参数是 $l$，右端石头的右参数是 $r$ 的方案

- 属性：最大值

**状态计算：**

- 集合划分依据：中间石子是什么 $l+1,l+2,...,r-2,r-1$
    - $f[l][r]=max(f[l][k]+f[k][r]+E[l][r]) ,(l<k<r)$

初始状态：$f[l][l+1]=0,(1≤l≤n)$

目标状态：$f[1][n+1]$，最后剩下一颗，所以是在 $1到n+1$ 之间

环形问题，参考环形石子合并，把链延长两倍

```c++
    for (int i = 1; i <= n; ++ i) scanf("%d", &w[i]), w[n + i] = w[i];
	memset(f, -0x3f, sizeof f);			// 没有负能量，这行可以去掉
    for (int len = 2; len <= n + 1; len++)
        for (int i = 1; i + len - 1 <= 2 * n; i++) {
            int l = i, r = i + len - 1;
            if (len == 2) {
                f[l][r] = 0;
                continue;
            }
            for (int k = l + 1; k < r; ++ k)
                f[l][r] = max(f[l][r], f[l][k] + f[k][r] + w[l] * w[k] * w[r]);
        }
    int res = 0;
    for (int i = 1; i <= n; ++ l) res = max(res, f[i][i + n]);	// 区间长度n+1
```





#### [1069. 凸多边形的划分](https://www.acwing.com/problem/content/1071/)

题目描述：

给定 $n$ 个点的 凸多边形 中每个 顶点 的 权值 $w_i$我们可以把该 凸多边形 划分成 n - 2 个 三角形(三角形不能相交，这样就能保证是 $n−2 $了)

每次划分三角形的 费用 为 三个顶点权值 的 乘积

求一个划分 方案，方案的 费用总和 最小

分析：

在 选定 多边形中 两个点 后，找出 三角形 的 第三个点 的方案有 $n−2$ 个

![IMG_6B91346846EE-1.jpeg](https://cdn.acwing.com/media/article/image/2021/08/12/55909_f09eb023fb-IMG_6B91346846EE-1.jpeg)

然后还要分别 划分 他的 左右两块区域，所以使用 区间DP

某个边最终一定会在一个三角形里，所以从哪个边开始做都可以，不需要环形分析

**状态表示：**$f[l][r]$

- 集合：当前划分到的多边形的左端点是 $l$，右端点是 $r$ 的方案
- 属性：最小值

**状态计算：**

- 集合划分的依据：根据 $l$ 和 $r$ 中间的点划分，把区间分成三部分，左区域+中间三角形+右区域

    $f[l][r] = min(f[l][k]+f[k][r]+w[l]*w[k]*w[r])$

```c++
// 基础
    for (int len = 3; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            f[l][r] = INF;
            for (int k = l + 1; k < r; k++)
                f[l][r] = min(f[l][r], f[l][k] + f[k][r] + w[l] * w[k] * w[r]);
        }
```

```c++
// 结合高精度
// 返回小的数
bool cmp(vector<int> &a, vector<int> &b) {
    if (a.size() != b.size()) return a.size() < b.size();
    for (int i = a.size() - 1; i >= 0; i -- )
        if (a[i] != b[i])
            return a[i] < b[i];
    return true;
}

// 加法
vector<int> add(const vector<int> &A, const vector<int> &B) {
    if (A.size() < B.size()) return add(B, A);
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ ) {
        t += A[i]; 
        if (i < B.size()) t += B[i]; //进位加上a和b第i位上的数
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}

// 乘法
vector<int> mul(const vector <int> & A, int b) {
    vector <int> C;
    LL t = 0;
    for (int i = 0; i < A.size(); i ++) {
        t += A[i] * b;       // t + A[i] * b = 7218
        C.push_back(t % 10); // 只取个位 8
        t /= 10;             // 721 看作 进位
    }
    while (t) {            // 处理最后剩余的 t
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    for (int len = 3; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            for (int k = l + 1; k < r; k++) {
                //w_l * w_k * w_r
                auto new_val = mul(mul({w[l]}, w[k]), w[r]);
                //f[l][k] + f[k][r] + cost
                new_val = add(add(new_val, f[l][k]), f[k][r]);
                //f[l][r] = min(f[l][r], f[l][k] + f[k][r] + w_sum)
                if (f[l][r].empty() || cmp(new_val, f[l][r])) f[l][r] = new_val;
            }
        }
    auto res = f[1][n];
    for (int i = res.size() - 1; i >= 0; i--) printf("%d", res[i]);
    puts("");
    return 0;
}
```



#### [479. 加分二叉树](https://www.acwing.com/problem/content/481/)

题目描述：

给定一个含有 $n$ 个节点的二叉树的 中序遍历 序列中每个节点的 权值

定义一颗 子树 的分数 为 左子树分数 × 右子树的分数 ＋ 根节点的权值

额外规定 空树 的分数 为 $1$

求一种满足该 中序遍历 的建树方案，使得整棵树的 分数 最大

**状态表示：**$f[i][j]$

- 集合：所有中序遍历是 [L, R] 这一段的二叉树的集合
- 属性：最大值

**状态计算：**

- 集合划分的依据：根据 $l$ 和 $r$ 中间的点划分，把区间分成三部分，左子树+根节点+右子树

    $left = k == l\  ?\  1 : f[l][k-1]$	$right=k==r\ ?\ 1:f[k+1][r]$

    $f[i][j] = left * right + w[k]$

- $root[l][r]$ 存储根节点的下标

```c++
void dfs(int l, int r) {
    if (l > r) return;      // 不构成节点
    int k = root[l][r];     // 根节点 
    printf("%d ", k);       // 分别递归左右子树
    dfs(l, k - 1);
    dfs(k + 1, r);
}

for (int len = 1; len <= n; len++)
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            if (len == 1) {         // 叶子节点
                f[l][r] = w[l];
                root[l][r] = l;
                continue;
            }
            for (int k = l; k <= r; k++) {
                int left = k == l ? 1 : f[l][k - 1];    // 如果k == l代表没有左子树
                int right = k == r ? 1 : f[k + 1][r];   // 如果k == r代表没有右子树
                int score = left * right + w[k];        // 分数计算
                if (f[l][r] < score) {                  // 更新信息 < 可以维护字典序
                    f[l][r] = score;
                    root[l][r] = k;
                }
            }
        }
```





## 树形DP模型

#### [1072. 树的最长路径(直径)](https://www.acwing.com/problem/content/1074/)

题目描述
给定一个含有 $n$ 个节点的 树，以及树中每条边的 权值 $w_{edge_i}$

现需要在树中找出一条 路径，使得该 路径 上所有 边 的 权值之和 最大

树上 任意两点 的路径是 唯一 确定的，因此我们可以暴力枚举 起点 和 终点 找出最长路径

转换枚举方式：枚举路径的 中间节点

![树形DP](https://cdn.acwing.com/media/article/image/2021/08/25/55909_2a282a8605-IMG_61398D0A7BFC-1.jpeg)

 红色节点，那么经过他的路径有：

1. 以其 子树中的某个节点 作为 起点，以他作为 终点 的 粉色路径
2. 以其 子树中的某个节点 作为 起点，以 子树中的某个节点 作为 终点 的 蓝色路径
3. 以其 子树中的某个节点 作为 起点，以 非其子树的节点 作为 终点 的 橙色路径

- 对于第 $1$ 种情况，我们可以直接递归处理其子树，找出到当前子树根节点最长的路径长度即可

- 对于第 $2$ 种情况，我们在处理第 $1$ 种情况时，顺便找出 $1$ 类路径的 次长路径

    把 最长 和 次长 拼在一起，就是我们要的第 $2$ 种情况

- 而对于第 $3$ 种情况，我们可以把它归类为其 祖先节点 的第 $1,2$ 种情况，让其 祖先节点 去处理即可

```c++
int res = 0;
int dfs(int u, int father) {
    int dist = 0;			// 表示从当前点往下走的最大长度
    int d1 = 0, d2 = 0;		// 如果是负数就当它不存在，边权是0
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j == father) continue;
        int d = dfs(j, u) + w[i];
        dist = max(dist, d);
        if (d >= d1) d2 = d1, d1 = d;	// 最长路转移
        else if (d > d2) d2 = d;		// 次长路转移
    }
    res = max(res, d1 + d2);
    return dist;
}
dfs(1, -1);			// 可以任意选取一个点作为根节点
```

**方法2：两次DFS**

1. 任选一点 $x$
2. 找到距离 $x$ 最远的点 $y$
3. 从 $y$ 开始遍历，找到离 $y$ 最远的点，与 $y$ 最远的点的距离是树的直径

```c++
int dist[N];		// 记录距离
void dfs(int u, int father, int distance) {			// father避免往回走
    dist[u] = distance;

    for (int i = h[i]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j != father)
            dfs(j, u, distance + w[i]);
}

// bfs需要额外st数组
bool st[N];
void bfs(int x) {
    queue<int> q;
    q.push(x);
    dist[x] = 0;
    st[x] = true;
    while (q.size()) {
        int t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (st[j]) continue;
            dist[j] = dist[t] + w[i];
            q.push(j);
            st[j] = true;
        }
    }
}
int main() {
    /*
    处理输入
    */
    dfs(1, -1, 0);						// 找到距离x最大的
    int u = 1;
    for (int i = 1; i <= n; i ++ )
        if (dist[i] > dist[u])
            u = i;

    dfs(u, -1, 0);
    for (int i = 1; i <= n; i ++ )
        if (dist[i] > dist[u])
            u = i;

    int s = dist[u];
    
}
```



#### [1073. 树的中心](https://www.acwing.com/problem/content/1075/)

题目描述**：**

给定一棵树，树中包含 $n$ 个 节点 和 $n−1$ 条 无向边，每条边都有一个权值 $w_{edge_i}$ 

请在树中找到一个点，使得该点到树中其他结点的 最远距离 最近

**分析：**

这个问题是 树形DP 中的一类 经典模型，常被称作 换根DP

同样，先来想一下如何暴力求解该问题：先 枚举 目标节点，然后求解该节点到其他节点的 最远距离

时间复杂度为 $O(n^2)$

**优化：**

在确定树的 拓扑结构 后单独求一个节点的 最远距离 时，会在该树上去比较哪些 路径 呢？

- 从当前节点往下，直到子树中某个节点的最长路径
- 从当前节点往上走到其父节点，再从其父节点出发且不回到该节点的最长路径

**换根DP：**

- 指定任意一个根节点
- 一次 dfs 遍历，统计出当前子树内的节点对当前节点的贡献
- 一次 dfs 遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案

1. 第一遍 dfs 预处理当前子树对于根的最大贡献（距离）和 次大贡献（距离）

    处理 次大贡献（距离） 的原因是：如果 当前节点 是其 父节点子树 的 最大路径 上的点，则 父节点子树 的 最大贡献 不能算作对该节点的贡献，因为我们的路径是 简单路径，不能 走回头路

2. 第二遍 dfs 求解出每个节点的父节点对他的贡献（即每个节点往上能到的最远路径）

3. 两者比较，取最大值

```c++
int d1[N], d2[N], up[N];	// d存u节点向下走的最长和次长距离 up存u节点向上走的最长路径的距离
int p1[N], p2[N];		    // p存u节点向下走的最长和次长路径是从哪一个点走下去的

int dfs_d(int u, int father) {			// 返回u的最长向下路径
	d1[u] = d2[u] = -INF;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j == father) continue;
        int d = dfs_d(j, u) + w[i];
        if (d >= d1[u]) {			   // 更新最长和次长的路径
            d2[u] = d1[u], d1[u] = d;	
            p2[u] = p1[u], p1[u] = j;	// 并记录下从该路径是从哪一个点下去的
        }
        else if (d > d2[u]) {
            d2[u] = d, p2[u] = j;
        }
    }
    if (d1[u] == -INF) d1[u] = d2[u] = 0; // 特判叶子结点(如果没有改变过该点的距离)
    return d1[u];
}

void dfs_u(int u, int father) {			// 用父节点更新子节点向上的最长路径
    for (int i = h[u]; i != -1; i = ne[i]) {
     	int j = e[i];
        if (j == father) continue;				// 如果从父节点向下的最长路径经过了要更新的子节点
        if (p1[u] == j) up[j] = max(up[u], d2[u]) + w[i];	// 那么用次长的路径更新
        else up[j] = max(up[u], d1[u]) + w[i];
        dfs_u(j, u);
    }
}

int res = INF;
for (int i = 1; i <= n; i++) res = min(res, max(d1[i], up[i]));
```



#### [1074. 二叉苹果树](https://www.acwing.com/problem/content/1076/)

题目描述：
给定一棵含有 $n$ 个结点的树，树根编号为 $1$，且树上的每条边有一个边权 $w_{edge_j}$

要求我们只保留树中的 $m$ 条边，使得 树根 所在的 连通块 的所有边 边权之和 最大

**分析：**

有依赖的背包 模型，不同的是把 物品价值 分给了 边 而不是 点

不过，对于一棵树来说，任意节点的入边（连向父节点的边） 都是 唯一 的

所以 边权 和 点权 在确定树的 根节点 以后，是可以视作一个东西的（入边价值 视作 该点价值）

**状态表示：**$f[u][j]$

集合：以 $u$ 为根节点的子树，包含 $i$ 的连通块的边数不超过 $j$ 的边权之和

属性：最大值

**状态计算：**

- 每一棵子树看出一组背包，若需要选择该子树son，则根结点 $u$ 到子树son的边一定用上，因此能用上的总边数一定减1，总共可以选择 $j$ 条边时，当前子树son分配的最大边数是 $j - 1$，对于任意一棵子树有
- $f[u][j]=max(f[u][j],\ f[u][j-1-k] + f[son][k] + w[i])$

```c++
void dfs(int u, int father) {
    for (int i = h[u]; i != -1; i = ne[i]) {
        int node = e[i];
        if (node == father) continue;
        dfs(node, u);
        for (int j = m; j >= 0; j--) {
            for (int k = 0; k <= j - 1; k++)    //  预留一个边连接父子
                f[u][j] = max(f[u][j], f[u][j - 1 - k] + f[node][k] + w[i]);
        }
    }
}
    dfs(1, -1);
    cout << f[1][m] << endl;
```



#### [285. 没有上司的舞会](https://www.acwing.com/problem/content/287/)

题目描述：

给定一颗包含 $n$ 个节点的树，以及树上的 $n-1$ 条边，每个节点有快乐值 $w$

我们需要在这 $n$ 个节点中，选择一定数量的节点参加舞会

其中父节点是子节点的直接上司，没有职员愿意和直接上司一起参会

求满足条件下的，选择节点的快乐值总和最大

**状态表示：**$f[i][j]$

- 集合：所有从以 $u$ 为根的子树中选择，不选择$(j==0)$ 或 选择$(j==1)$ $u$ 这个点的方案
- 属性：最大值

**状态计算：**

- 集合划分的依据：不选 $u$ 和 选 $u$，$S$ 代表节点 $u$ 的下属集合

    $f[u][0] = ∑max(f[S_i][0], f[S_i][1])$

    $f[u][1]=∑f[S_i][0]$

```c++
int f[N][2];
void dfs(int u) {
    f[u][0] = 0;	// 初始的高兴度
    f[u][1] = w[u];	// 1代表这个boss要来，先加上他来的利益
    for (int i = h[u]; i != -1; i = ne[i]) {	// 遍历树
    	int j = e[i];
        dfs(j);		// 回溯
        f[u][0] += max(f[j][1],f[j][0]);
        // boss不来，那小弟就是王了，但小弟要以利益为重，如果小小弟来可以获利更大，就让小小弟来
        f[u][1] += f[j][0]; 
        // boss来了！！！小弟都承让
    }
}
    dfs(root);
    cout << max(f[root][0], f[root][1]) << endl;
```



#### [323. 战略游戏](https://www.acwing.com/problem/content/325/)

题目描述：

给定一颗包含 $n$ 个节点的树，以及树上的 $n-1$ 条边

我们需要在这 $n$ 个节点中，选择一定数量的节点放上哨兵

最终要求，树中任意 $n−1$ 条边的左右两端，至少有一个结点上放置了哨兵

求满足条件下的，放置的哨兵数量最少

**分析：**

考虑以结点 $u$ 为 根节点 的子树，该子树所有的 方案，可以由当前节点 放 或 不放哨兵 进行划分

- 如果当前结点放置了哨兵(1)，则该子树中，连向他的边的另一端，可以放置(1)，也可以不放置(0)
- 如果当前结点没有放哨兵(0)，则该子树中，连向他的边的另一端，必须可以放置(1)

**状态表示：**$f[i][0]、f[i][1]$

- 集合：以节点 $i$ 为 根节点 的子树，在 $i$ 上放置哨兵(1)和不放哨兵(0)的方案
- 属性：最小值

**状态计算：**

集合划分的依据：不选 $u$ 和 选 $u$，$S$ 代表节点 $u$ 的子节点集合

$f[u][0]=∑f[S_i][0]$

$f[u][1] = ∑min(f[S_i][0], f[S_i][1])$

```c++
void dfs(int u) {
    f[u][0] = 0, f[u][1] = 1;  //initialize
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        dfs(j);
        f[u][0] += f[j][1];
        f[u][1] += min(f[j][0], f[j][1]);
    }
}
    dfs(root);
    printf("%d\n", min(f[root][0], f[root][1]));
```



#### [1077. 皇宫看守](https://www.acwing.com/problem/content/1079/)

题目描述：

给定一棵树，要在一些节点上放置守卫，每个守卫可以看护当前节点以及与此节点连通的节点，在不同节点放置守卫的代价不同，如何选取节点使代价最小

分析：

这是个典型的树形DP问题，显然每个节点有放置守卫和不放置守卫两种，但是从计算的过程看，不放置守卫的状态由两种，一种是有其父节点上的守卫看护，一种是由其子节点的守卫看护，因此可将每个节点的看护情况分为三种：

- 该节点由父节点处放置的守卫看护
- 该节点由子节点处放置的守护看护
- 该节点由在该节点放置的守卫看护

下面考虑状态转移的过程，建立数组$f[i][3]$，其中

- $f[i][0]$表示第i个节点由父节点处放置的守卫看护下的最小代价
- $f[i][1]$表示第i个节点由子节点处放置的守卫看护下的最小代价
- $f[i][2]$表示第i个节点由在该节点放置的守卫看护下的最小代价

转移关系：

- $f[u][0] += min(f[j][1], f[j][2])$

- $f[u][1] = min(f[u][1], sum - min(f[j][1], f[j][2]) + f[j][2])$

    $sum$ 为所有子节点 $j$ 的 $min(f[j][1],f[j][2])$ 的和，如果第 $i$ 个节点由子节点守卫，那么所有子节点都不能由父节点守卫，并且每个子节点都得到了守卫，且至少有一个子节点处放置了守卫

    子节点一定得选一个，在计算过程中sum记录了所有边，所以遍历所有边，统计放置某个子节点的最小值

- $f[u][2] += min(min(f[u][0], f[u][1]), f[u][2]);$

```c++
void dfs(int u) {
    f[u][2] = w[u];
    int sum = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        dfs(j);
        f[u][0] += min(f[j][1], f[j][2]);
        f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]);
        sum += min(f[j][1], f[j][2]);
    }
    f[u][1] = 1e9;
    for (int i = h[u]; ~i; i = ne[i]) {     // 遍历所有节点，选最小的
        int j = e[i];
        // f[u][0]中记录了sum{min(f(j,1), f(j,2))}，再从中减去对应的贡献即可得到
        // 
        // f[u][1] = min(f[u][1], f[u][0] + f[j][2] - min(f[j][1], f[j][2]));
        f[u][1] = min(f[u][1], sum - min(f[j][1], f[j][2]) + f[j][2]);
    }
}

    dfs(root);
    cout << min(f[root][1], f[root][2]) << endl;
```



## 单调队列优化DP

做法：首先写出普通版的朴素DP，接着再用单调队列优化DP

DP在计算过程中，如果有求所有固定窗口类的最值，就可以用单调队列优化



#### [135. 最大子序和](https://www.acwing.com/problem/content/137/)

题目描述：

给定一个长度为 $n$ 的序列 $a$，找出其中 元素总和最大 且 长度 不超过 $m$ 的 连续子区间

分析：

看到求一段 连续区间 的和的问题，会想到用 前缀和 进行优化，然后就是 枚举 区间的问题，暴力枚举右端点在枚举左端点$O(n^2)$超时，不妨先枚举右端点

**状态表示：**$f[i]$

- 集合：以 $i$ 为右端点，长度不超过 $m$ 的连续子区间
- 属性：区间总和的最大值

**状态计算：**

- 集合划分的依据：子区间长度 $1→m$
- $f[i] = max(s[i]-s[j]),\ \ \ (1≤i-j≤m),(i-m≤j≤i-1)$
- $s[i]$是常量，可以提到外面：$f[i]=s[i]-min(s[j]),\ (1≤i-j≤m)$

从前向后 维护一个长度不超过 $m$ 的区间的 最小值，就想到我们最熟悉的 滑动窗口模型 了

```c++
/*
eg:i = 10, m = 3	以10为终点的区间最大和时，队列中存入的应该是 7,8,9的索引号
(1)m=3 ->8 9 10  a[8]+a[9]+a[10]=s[10]-s[7]
(2)m=2 ->9 10    a[9]+a[10]=s[10]-s[8]
(3)m=1 ->10      a[10]=s[10]-s[9]
队列存储的是以i的上一个元素为结尾，长度为m的上升序列
 */
    int hh = 0, tt = 0;     // 等价于增加了一个哨兵节点,也就是把下标为0的前缀和s[0]=0加入了滑动窗口中
    for (int i = 1; i <= n; i++) {
        if (i - q[hh] > m) hh++;    // 队列维护的是下标为i-1，长度为m的上升序列 元素个数 i-1-q[hh]+1
        res = max(res, s[i] - s[q[hh]]);	// 此时i还没有进入队列，单调队列其实在枚举数字i的左侧
        while (hh <= tt && s[i] <= s[q[tt]]) tt--;	// 比i老没它小的都去死吧~
        q[++tt] = 1;
    }
```





#### [1089. 烽火传递](https://www.acwing.com/problem/content/1091/)

给定一个长度为 $n$ 的数组 $w$，以及一个正整数 $m$，其中 $w_i$ 表示第 $i$ 个 元素 的 价值

求一种选择元素的 方案：

1. 使得选择的 相邻元素 之间相差 不超过 $m−1$ 个 不选 的元素
2. 选择的元素总贡献 最小

分析：

**状态表示：**$f[i]$

- 集合：以 $i$ 为右端点的前缀区间，表示前 $1—i$ 座烽火台满足条件，并且选择第 $i$ 个元素的方案
- 属性：最小值

**状态计算：**

- 集合划分的依据：子区间长度 $1→m$ 内点燃2个烽火台

- $f_i = min(f_j+w_i)\ \ \ \ (0 ≤ i-j+1 ≤ m - 1)$
- $f_i = w_i + min(f_j)\ \ \ \ (1 ≤ i - j ≤ m)$

**有限范围** 的 $j$ 和分离开常量后的 **最小值函数**，直接套 **单调队列模板**

```c++
    int hh = 0, tt = 0;		// 哨兵，窗口存的是以i-1结尾的
    for (int i = 1; i <= n; i++) {
        while (hh <= tt && i - q[hh] > m) hh++;	// i-1-q[hh]+1>m
        f[i] = f[q[hh]] + a[i];				   // 更新答案
        while (hh <= tt && f[i] <= f[q[tt]]) tt--;	// 维护队列 杀掉点的早而且花费大的
        q[++tt] = i;
    }
    int res = 1e9;
    for (int i = n - m + 1; i <= n; i++) res = min(res, f[i]); //答案在最后一段区间选
```





# 搜索

BFS特点：

- 求最短路
- 基于迭代、不会爆栈

## Flood Fill

洪水填充法，**统计连通块的数量**

**可以在线性时间复杂度内，找到某个点所在的连通块**

做法：遍历地图，找到需要统计的点，深搜或者宽搜

深搜/宽搜过程中遍历周围的点，符合条件则继续深搜

#### [1097. 池塘计数](https://www.acwing.com/problem/content/1099/)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
char g[N][N];

int dx[8] = {-1, 0, 1, 0, -1, 1, 1, -1};
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};

void dfs(int x, int y) {
    g[x][y] = '.';
    for (int i = 0; i < 8; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= n || b < 0 || b >= m || g[a][b] == '.') continue;
        dfs(a, b);
    }
} 

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> g[i];
    
    int res = 0;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < m; j++) 
            if (g[i][j] == 'W') dfs(i, j), res++;
    cout << res << endl;
    return 0;
}

void bfs(int x, int y) {
    g[x][y] = '.';
    queue<pair<int, int>> q;
    q.push({x, y});
    while (q.size()) {
        auto t = q.front();
        q.pop();
        
        // 八连通可以这样写
        // for (int i = t.first - 1; i <= t.first + 1; i++)
        //     for (int j = t.second - 1; j <= t.second + 1; j++) {
        //	       if (i == t.x && j == t.y) continue;
    	//}
        for (int i = 0; i < 8; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m || g[a][b] == '.') continue;
            q.push({a, b});
            g[a][b] = '.';
        }
    }
}
```



#### [1098. 城堡问题](https://www.acwing.com/problem/content/1100/)

用二进制位表示哪个方向有墙

```c++
// 0001 西 、0010 北、0100 东、1000南
int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};
```

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 55;
int n, m;
int g[N][N];
bool st[N][N];

// 西 0 北 1 东 2 南 3
int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};

int bfs(int sx, int sy) {
    queue<PII> q;
    int area = 0;
    q.push({sx, sy});
    st[sx][sy] = true;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        area++;
        for (int i = 0; i < 4; i++) {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (st[a][b]) continue;
            if (g[t.x][t.y] >> i & 1) continue;
            q.push({a, b});
            st[a][b] = true;
            
        }
    }
    return area;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];
    
    int cnt = 0, area = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) 
            if (!st[i][j]) {
                area = max(area, bfs(i, j));
                cnt++;
            }
    cout << cnt << endl;
    cout << area << endl;
    
    return 0;
}
```



#### [1106. 山峰和山谷](https://www.acwing.com/problem/content/1108/)

**思路**
这里我们暴搜所有一个点之间所有高度相等的点，如果周围的点都高于或低于当前点，那么这个就是一个山谷或山峰。

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010;

int n;
int g[N][N];
bool st[N][N];

void bfs(int sx, int sy, bool& has_higher, bool& has_lower) {
    queue<PII> q;
    q.push({sx, sy});
    st[sx][sy] = true;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        
        for (int i = t.x - 1; i <= t.x + 1; i++)
            for (int j = t.y - 1; j <= t.y + 1; j++) {
                if (i == t.x && j == t.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= n) continue;
                if (g[i][j] != g[t.x][t.y]) {
                    if (g[i][j] > g[t.x][t.y]) has_higher  = true;
                    else has_lower = true;
                } else if (!st[i][j]) {
                    q.push({i, j});
                    st[i][j] = true;
                }
            }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &g[i][j]);
    
    int peak = 0, valley = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) 
            if (!st[i][j]) {
                bool has_higher = false, has_lower = false;
                bfs(i, j, has_higher, has_lower);
                if (!has_higher) peak++;
                if (!has_lower) valley++;
            }
    cout << peak <<  ' ' << valley << endl;
    return 0;
}
```



## 最短路模型

#### [1076. 迷宫问题](https://www.acwing.com/problem/content/1078/)

BFS寻找最短路路径，`bool st[][]` 数组修改成 `PII pre[][]` 数组

数组记录 转移到这个点的的下标，同时初值置成 `{-1, -1}`，可以判断是否经过这个点

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;
int n;
int g[N][N];
PII pre[N][N];      // 记录的是上一个点的下标

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void bfs(int sx, int sy) {
    queue<PII> q;
    q.push({sx, sy});
    memset(pre, -1, sizeof pre);
    pre[sx][sy] = {0, 0};           // 记录上一个点下标
    while (q.size()) {
        PII t = q.front();
        q.pop();
        for (int i = 0; i < 4; i++) {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= n) continue;
            if (g[a][b]) continue;              // 只能走0
            if (pre[a][b].x != -1) continue;    // 已经遍历过
            q.push({a, b});
            pre[a][b] = t;
        }
    }
}

void dfs(int sx, int sy) {			  // 递归输出答案
    if (sx == 0 && sy == 0) {
        cout << 0 << " " << 0 << endl;
        return ;
    }
    dfs(pre[sx][sy].x, pre[sx][sy].y);  // 递归到{0, 0}
    printf("%d %d\n", sx, sy);
}
int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &g[i][j]);
    
    bfs(0, 0);
    dfs(n - 1, n - 1);

    return 0;
}
```



#### [188. 武士风度的牛](https://www.acwing.com/problem/content/190/)

BFS寻找最短路长度，`bool st[][]` 数组修改成 `int dist[][]` 数组

数组记录起点到该点的距离，同时初值置成 `-1`，可以判断是否经过这个点

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 155;

int n, m;
char g[N][N];
int dist[N][N];

int bfs() {
    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};
    
    int sx, sy;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (g[i][j] == 'K')
                sx = i, sy = j;
    
    memset(dist, -1, sizeof dist);
    queue<PII> q;
    q.push({sx, sy});
    dist[sx][sy] = 0;
    
    while (q.size()) {
        auto t = q.front();
        q.pop();
        for (int i = 0; i < 8; i++) {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (g[a][b] == '*') continue;
            if (dist[a][b] != -1) continue;
            if (g[a][b] == 'H') return dist[t.x][t.y] + 1;
            q.push({a, b});
            dist[a][b] = dist[t.x][t.y] + 1;
        }
    }
    return -1;
}


int main() {
    cin >> m >> n;
    for (int i = 0; i < n; i++) cin >> g[i];
    cout << bfs() << endl;
    
    return 0;
}
```



#### [1100. 抓住那头牛](https://www.acwing.com/problem/content/1102/)

宽度优先搜索，队列
几种方案依次模拟一下就行了
只要最后到了牛的位置，我们就输出

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n, k;
int dist[N];

int bfs() {
    memset(dist, -1, sizeof dist);
    dist[n] = 0;
    queue<int> q;
    q.push(n);
    while (q.size()) {
        int t = q.front();
        q.pop();
        if (t == k) return dist[k];
        if (t + 1 < N && dist[t + 1] == -1) {
            dist[t + 1] = dist[t] + 1;
            q.push(t + 1);
        }
        if (t - 1 >= 0 && dist[t - 1] == -1) {
            dist[t - 1] = dist[t] + 1;
            q.push(t - 1);
        }
        if (t * 2 < N && dist[t * 2] == -1) {
            dist[t * 2] = dist[t] + 1;
            q.push(t * 2);
        }
    }
    return -1;
}


int main() {
    cin >> n >> k;
    cout << bfs() << endl;
    
    return 0;
}
```



## 多源BFS

可以看作一道有多个起始状态的Flood FIll。把矩阵中每一个符合状态开始的都看做起点 ，整个矩阵的所有位置都可以同行，对于每个位置，再从任何一个起点出发都可以的情况下，求到达该位置所需要的最少步数。

只需要 BFS 开始之前，把这些起始状态全部加入队列，根据 BFS 逐层搜索。

**类似图论中虚拟源点的思路。**

#### [173. 矩阵距离](https://www.acwing.com/problem/content/175/)

先遍历一遍矩阵，把所有起点插入队列，并修改距离 `dist[][]=0`，逐层 BFS。

```c++
#include <bits/stdc++.h>

#define x first
#define y second

using namespace std;

const int N = 1010;

int n, m;
char g[N][N];
int dist[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

typedef pair<int, int> PII;

void bfs() {
    memset(dist, -1, sizeof dist);
    
    queue<PII> q;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            if (g[i][j] == '1') {
                dist[i][j] = 0;
                q.push({i, j});
            }
        }
    
    while (q.size()) {
        auto t = q.front();
        q.pop();
        for (int i = 0; i < 4; i++) {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (dist[a][b] != -1) continue;
            dist[a][b] = dist[t.x][t.y] + 1;
            q.push({a, b});
        }
    }
    
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> g[i];
    bfs();

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) 
            printf("%d ", dist[i][j]);
        puts("");
    }
    return 0;
}
```



## 最小步数模型

额外用一个哈希表，统计该种状态 是否出现过 以及 出现的需要的步数。

#### [1107. 魔板](https://www.acwing.com/problem/content/1109/)

类似八数码，额外用哈希表记录状态的步数，字典序最短则说明按照字典序优先变动即可。

```c++
#include <bits/stdc++.h>
#define x first
#define y second

using namespace std;

typedef pair<char, string> PII;

const int N = 10;
int n;
string start, ed;
unordered_map<string, int> dist;		// 当前状态需要的步数
unordered_map<string, PII> pre;			// 记录当前状态的上一个状态，以及转移方式

string get(string t, int op) {	// 3种状态
    string k;
    if (op == 0) k = {t[4], t[5], t[6], t[7], t[0], t[1], t[2], t[3]};      // A
    if (op == 1) k = {t[3], t[0], t[1], t[2], t[7], t[4], t[5], t[6]};      // B
    if (op == 2) k = {t[0], t[5], t[1], t[3], t[4], t[6], t[2], t[7]};      // C
    return k;
}

void bfs(string start) {

    queue<string> q;
    dist[start] = 0;
    q.push(start);
    while (q.size()) {
        auto t = q.front();
        q.pop();
        if (t == ed) return;
        for (int i = 0; i < 3; i++) {
            string s = get(t, i);

            if (!dist.count(s)) {
                dist[s] = dist[t] + 1;
                pre[s] = {'A' + i, t};
                q.push(s);
            }
        }
    }
}

void dfs(string end) {			// 递归找到第一个顺序输出
    if (end == start) {
        return;
    }
    dfs(pre[end].y);
    printf("%c",pre[end].x);
}

int main() {
    
    for (int i = 0; i < 8; i++) {
        int x;
        cin >> x;
        ed += x + '0';
    }
    reverse(ed.begin() + 4, ed.end());
    start = "12348765";
    bfs(start);
    cout << dist[ed] << endl;
    dfs(ed);
    return 0;
}
```

